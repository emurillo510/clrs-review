/**
 * Bucketsort assumes that the input is drawn from a uniform distribution and has an 
 * average-case running time of O(n). Like counting sort, bucket sort is fast because
 * it assumes something about the input.
 * 
 * Where as counting sort assumes that the input consist of integers in a small range,
 * bucket sort assumes that the input is generated by a random process that distributes
 * elements uniformly and independently over the interal [0,1).
 * 
 * Bucket sort divides interval [0,1) into n equal-sized subintervals, or buckets
 * and then distributes the n input numbers into the buckets.
 * 
 * Since the inputs are uniformly and independently distributed over [0,1), we do not
 * expect many numbers to fall into the bucket. 
 * 
 * To produce the output, we simply sort the numbers in each bucket and go through the buckets in
 * order , listing the elements as such.
 * 
 * 
*/
function bucketSort(){

    /**
     * let B[0..n-1] be a new array
     * 
     * n = A.length
     * 
     * for i = 0 to n - 1
     *   make B[i] an empty list
     * 
     * for i = 1 to n
     *   insert A[i] into list B[Math.floor(n[A[i]])]
     * for i = 0 to n - 1
     *   sort list B[i] with insertion sort
     * concatenate the lists B[0], B[1], ...,B[n-1] together in order
     * 
     * 
    */

}

let list = [10,9,8,7,6,5,4,3,2,1];
let size = list.length;

let result = countingSort(list,0,size-1);
console.log(result);